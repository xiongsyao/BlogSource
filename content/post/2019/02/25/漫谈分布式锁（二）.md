---
title: "漫谈分布式锁（二）"
date: 2019-02-25T17:20:58+08:00
tags: ["锁"， "分布式"]
categories: ["分布式"]
draft: true
---

## 回顾

在上一节中，我们利用MySQL实现了一个简单的分布式锁，但是，这样实现的分布式锁存在以下缺点：

1. IO时间过长，获取锁与释放锁的过程远不如从内存中获取快。
2. 锁没有失效时间，解锁失败会导致死锁，其他线程无法再获取到锁。
3. 只能是阻塞锁或非阻塞锁。
4. 不可重入，同一线程在没有释放锁之前无法再获取到锁。

这一节，我们尝试用Redis实现，看看是否能解决上述问题。

## 单机实现

类比MySQL的方案1，我们在Redis中也只需要在加锁时设置(setnx, set if not exists)一个唯一的key（假如这个key已存在，则加锁失败），释放锁时删除(delete)这个key，同时，针对MySQL加锁的问题2，我们可以利用expire为这个key主动设置失效时间。
假如我们需要占用一把名为Rlocker的锁，用Redis命令表示出来为:
"""
> SETNX Rlocker 1     # 加锁：SETNX仅当key不存在时，才会设置成功，返回1， 否则返回0
(integer) 1
> EXPIRE Rlocker 1    # 设置失效时间: EXPIRE设置当前key失效时间，单位为秒，PEXPIRE单位为毫秒
(integer) 1
> DEL Rlocker         # 释放锁
(integer) 0
"""
