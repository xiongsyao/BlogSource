---
title: "漫谈分布式锁（二）"
date: 2019-02-25T17:20:58+08:00
tags: ["锁"， "分布式"]
categories: ["分布式"]
draft: true
---

## 回顾

在上一节中，我们利用MySQL实现了一个简单的分布式锁，但是，这样实现的分布式锁存在以下缺点：

1. IO时间过长，获取锁与释放锁的过程远不如从内存中获取快。
2. 锁没有失效时间，解锁失败会导致死锁，其他线程无法再获取到锁。
3. 只能是阻塞锁或非阻塞锁。
4. 不可重入，同一线程在没有释放锁之前无法再获取到锁。

这一节，我们尝试用Redis实现，看看是否能解决上述问题。

## 单机实现

类比MySQL的方案1，我们可以快速给出一个粗糙的思路：

在Redis中只需要在加锁时设置(setnx, set if not exists)一个唯一的key，并且值也为特殊生成的uuid，更具setnx的特性，假如这个key已存在，则加锁失败，不存在，则枷锁成功。同时，针对MySQL加锁的问题2，我们可以利用expire为这个key主动设置失效时间。释放锁时，通过比较`GET key`的值与线程的锁的uuid是否一致，如果相等，则说明是同一把锁，通过`delete`就可以删除这把锁，不一致，就表示可能业务逻辑超时或者网络延迟，导致锁已经失效，此时不做任何处理，防止影响其他线程正常使用锁。

假如我们需要占用一把名为Rlocker的锁，用Redis命令表示出来为:

```sh
> SETNX Rlocker uuid  # 加锁：SETNX仅当key不存在时，才会设置成功，返回1， 否则返回0
(integer) 1
> EXPIRE Rlocker 1    # 设置失效时间: EXPIRE设置当前key失效时间，单位为秒，PEXPIRE单位为毫秒
(integer) 1
> DEL Rlocker         # 释放锁
(integer) 0
```

实现一个简单的ReMutex类:

```python
import uuid
import redis

r = redis.Redis(host="localhost", port=6379, db=0)

class ReMutex:
    def __init__(self, name, pexpire=500):
        self.name = name
        self._key = "re:locker:{}".format(name)
        self._uuid = str(uuid.uuid1())  # 这里最好替换成其他的id生成算法
        self._pexpire = pexpire

    def lock(self):
        if r.setnx(self._key, self._uuid):
            r.pexpire(self._key, self._pexpire)
        raise Exception("Locker is used by other one!")

    def unlock(self):
        if r.get(self._key) == self._uuid:
            r.delete(self._key)
```

仔细思考一下，这样的代码真的正确吗？假如在`SETNX`后客户端异常，导致没有发出`EXPIRE`命令，会形成死锁；亦或是`GET`请求后，恰好key过期，另一个线程获取了锁，错误的删除了另一个线程持有的锁。归根结底，这样的代码是没办法保证原子性的。

首先，我们需要整合`SETNX`与`EXPIRE`命令。

这个很好解决，采用Redis2.6.12版本后提供的set，它提供了一系列选项

+ EX seconds - 设置key的过期时间，单位为秒
+ PX milliseconds - 设置ke的过期时间，单位为毫秒
+ NX - 只有key不存在时才设置key的值
+ XX - 只有key存在时才设置key的值

上述的步骤可以整合成一个原子性的命令:`SET Rlocker uuid EX 1 NX`。

其次，`GET`的值判断与`DELETE`我们可以借助`lua`整合成一个命令，确保其原子性。

```lua
if redis.call('get', KEYS[1]) == ARGV[1] then 
    return redis.call('del', KEYS[1]) 
else 
    return 0 
end
```

这样，修改后的ReMutex类为:

```python
class ReMutex:
    def __init__(self, name, pexpire=500):
        self.name = name
        self._key = "re:locker:{}".format(name)
        self._uuid = str(uuid.uuid1())  # 这里最好替换成其他的id生成算法
        self._pexpire = pexpire

    def lock(self):
        if not r.set(self._key, self._uuid, px=self._pexpire, nx=True):
            raise Exception("Locker is used by other one!")

    def unlock(self):
        slua = """
        if redis.call('get', KEYS[1]) == ARGV[1] then 
            return redis.call('del', KEYS[1]) 
        else 
            return 0 
        end
        """
        get_then_delete = r.register_script(slua)
        return get_then_delete(keys=[self._key], args=[self._uuid])
```
